{"version":3,"file":"index.2cd8e0dd.js","sources":["../../src/components/fields/image-upload/image-manager/image-manager.ts"],"sourcesContent":["import { useContext, useEffect, useRef } from \"react\";\nimport { useFormContext } from \"react-hook-form\";\nimport { AxiosApiClient, FileHelper, ImageHelper, generateRandomId } from \"../../../../utils\";\nimport { useFieldEvent, usePrevious } from \"../../../../utils/hooks\";\nimport { ImageContext } from \"../image-context\";\nimport {\n\tEImageStatus,\n\tIImage,\n\tISharedImageProps,\n\tIUpdateImageStatus,\n\tTImageUploadOutputFileType,\n\tTUploadMethod,\n} from \"../types\";\n\ninterface IProps extends Omit<ISharedImageProps, \"maxFiles\"> {\n\teditImage: boolean;\n\tcompress: boolean;\n\tcrop: boolean;\n\tdimensions: { width: number; height: number };\n\toutputType: TImageUploadOutputFileType;\n\tupload?: {\n\t\tmethod: TUploadMethod;\n\t\turl: string;\n\t\tsessionId?: string | undefined;\n\t};\n\tvalue: any;\n}\n\n/**\n * manages selected images by listening to images from context provider\n * rename / compress / upload\n */\nexport const ImageManager = (props: IProps) => {\n\t// =============================================================================\n\t// CONST, STATE, REFS\n\t// =============================================================================\n\tconst { accepts, compress, crop, dimensions, editImage, id, maxSizeInKb, outputType, upload, value } = props;\n\tconst { images, setImages, setErrorCount, setCurrentFileIds } = useContext(ImageContext);\n\tconst previousImages = usePrevious(images);\n\tconst previousValue = usePrevious(value);\n\tconst { setValue } = useFormContext();\n\tconst sessionId = useRef<string>();\n\tconst managerErrorCount = useRef(0);\n\n\tconst { dispatchFieldEvent, addFieldEventListener, removeFieldEventListener } = useFieldEvent();\n\n\t// =============================================================================\n\t// EFFECTS\n\t// =============================================================================\n\tuseEffect(() => {\n\t\tconst handleUpdateImageStatus = (e: CustomEvent<IUpdateImageStatus>) => {\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst imageIndex = prev.findIndex((image) => image.id === e.detail.id);\n\t\t\t\tconst updatedImage = { ...prev[imageIndex] };\n\t\t\t\tupdatedImage.status = e.detail.updatedStatus;\n\t\t\t\tupdatedImage.customErrorMessage = e.detail.errorMessage;\n\n\t\t\t\tconst newImages = [...prev];\n\t\t\t\tnewImages.splice(imageIndex, 1, updatedImage);\n\t\t\t\treturn newImages;\n\t\t\t});\n\t\t};\n\n\t\taddFieldEventListener(\"update-image-status\", id, handleUpdateImageStatus);\n\t\treturn () => removeFieldEventListener(\"update-image-status\", id, handleUpdateImageStatus);\n\t}, [addFieldEventListener, id, removeFieldEventListener, setImages]);\n\n\t// generate pseudo-random session id\n\tuseEffect(() => {\n\t\tsessionId.current = generateRandomId();\n\t}, []);\n\n\tuseEffect(() => {\n\t\timages.forEach((image, index) => {\n\t\t\tconst previousFile = previousImages?.[index];\n\t\t\tif (image.status !== previousFile?.status || image.dataURL !== previousFile.dataURL) {\n\t\t\t\tswitch (image.status) {\n\t\t\t\t\tcase EImageStatus.INJECTED:\n\t\t\t\t\t\tFileHelper.dataUrlToBlob(image.dataURL)\n\t\t\t\t\t\t\t.then((blob) => {\n\t\t\t\t\t\t\t\tsetImages((prev) => {\n\t\t\t\t\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t\t\t\t\t...image,\n\t\t\t\t\t\t\t\t\t\tfile: new File([blob], image.name),\n\t\t\t\t\t\t\t\t\t\tstatus: EImageStatus.NONE,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\treturn updatedImages;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\t\tsetImages((prev) => prev.filter((prev, i) => i !== index));\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.NONE:\n\t\t\t\t\t\tFileHelper.getType(image.file).then((fileType) => {\n\t\t\t\t\t\t\tconst mimeType = fileType.mime;\n\t\t\t\t\t\t\tif (mimeType && accepts.map(FileHelper.fileExtensionToMimeType).includes(mimeType)) {\n\t\t\t\t\t\t\t\tsetImages((prev) => {\n\t\t\t\t\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t\t\t\t\t...image,\n\t\t\t\t\t\t\t\t\t\tname: FileHelper.deduplicateFileName(\n\t\t\t\t\t\t\t\t\t\t\timages.map(({ name }) => name),\n\t\t\t\t\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\t\t\t\t\tFileHelper.sanitizeFileName(image.name)\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\ttype: mimeType,\n\t\t\t\t\t\t\t\t\t\tstatus: image.addedFrom !== \"schema\" ? image.status : EImageStatus.UPLOADED,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\treturn updatedImages;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (image.addedFrom !== \"schema\") {\n\t\t\t\t\t\t\t\t\tcompress ? compressImage(index, image) : convertImage(index, image);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsetImages((prev) => {\n\t\t\t\t\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t\t\t\t\t...image,\n\t\t\t\t\t\t\t\t\t\tstatus: EImageStatus.ERROR_FORMAT,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\treturn updatedImages;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.TO_RECOMPRESS:\n\t\t\t\t\t\trecompressImage(index, image);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.COMPRESSED:\n\t\t\t\t\tcase EImageStatus.CONVERTED:\n\t\t\t\t\tcase EImageStatus.RECOMPRESSED:\n\t\t\t\t\t\tif (!editImage) {\n\t\t\t\t\t\t\tconst shouldPreventDefault = !dispatchFieldEvent(\"upload-ready\", id, { imageData: image });\n\n\t\t\t\t\t\t\tsetImages((prev) => {\n\t\t\t\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t\t\t\t...updatedImages[index],\n\t\t\t\t\t\t\t\t\tstatus: shouldPreventDefault ? EImageStatus.PENDING : EImageStatus.UPLOAD_READY,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn updatedImages;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.UPLOAD_READY:\n\t\t\t\t\t\tuploadImage(index, image);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.TO_DELETE:\n\t\t\t\t\t\tsetImages((prev) => prev.filter(({ status }) => status !== EImageStatus.TO_DELETE));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EImageStatus.UPLOADED:\n\t\t\t\t\t\tdispatchFieldEvent(\"uploaded\", id, { imageData: image });\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [images.map(({ status }) => status).join(\",\"), images.map(({ dataURL }) => dataURL).join(\",\")]);\n\n\t// track / update errors and values\n\tuseEffect(() => {\n\t\tlet updatedManagerErrorCount = 0;\n\t\timages.forEach((image) => {\n\t\t\tif (\n\t\t\t\t(image.type && !accepts.map(FileHelper.fileExtensionToMimeType).includes(image.type)) ||\n\t\t\t\t[EImageStatus.ERROR_GENERIC, EImageStatus.ERROR_SIZE].includes(image.status)\n\t\t\t) {\n\t\t\t\tupdatedManagerErrorCount++;\n\t\t\t}\n\t\t});\n\t\tsetErrorCount((prev) => Math.max(0, prev + updatedManagerErrorCount - managerErrorCount.current));\n\t\tmanagerErrorCount.current = updatedManagerErrorCount;\n\n\t\tconst uploadedImages = images.filter(\n\t\t\t({ status }) => status === EImageStatus.UPLOADED || status === EImageStatus.ERROR_CUSTOM_MUTED\n\t\t);\n\t\tconst notPrefilledImages = uploadedImages.filter(({ addedFrom }) => addedFrom !== \"schema\");\n\t\tconst gotDeleteImages = images.filter(({ status }) => status === EImageStatus.TO_DELETE).length > 0;\n\n\t\t/**\n\t\t * should dirty if\n\t\t * - it is dirty in the first place\n\t\t * - there are non-prefilled images\n\t\t * - user deleted image (differentiated from reset)\n\t\t */\n\t\tconst hasNotPrefilledImages = notPrefilledImages.length > 0;\n\t\tconst shouldDirty = hasNotPrefilledImages || gotDeleteImages;\n\n\t\tsetCurrentFileIds(uploadedImages.map(({ id }) => id));\n\n\t\tsetValue(\n\t\t\tid,\n\t\t\tuploadedImages.map(({ id, dataURL, drawingDataURL, name, metadata, uploadResponse }) => ({\n\t\t\t\tfileId: id,\n\t\t\t\tfileName: name,\n\t\t\t\tdataURL: drawingDataURL || dataURL,\n\t\t\t\tmetadata,\n\t\t\t\tuploadResponse,\n\t\t\t})),\n\t\t\t{ shouldDirty, shouldTouch: hasNotPrefilledImages }\n\t\t);\n\t}, [accepts, id, images, setErrorCount, setValue]);\n\n\tuseEffect(() => {\n\t\tif (previousValue !== undefined && value === undefined && images.length) {\n\t\t\tsetImages([]);\n\t\t}\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [previousValue === undefined, value === undefined, images.length]);\n\n\t// =============================================================================\n\t// HELPER FUNCTIONS\n\t// =============================================================================\n\tconst getScale = (origWidth: number, origHeight: number): number => {\n\t\tlet scale = dimensions.width / origWidth;\n\t\tif (origHeight * scale > dimensions.height) {\n\t\t\tscale = dimensions.height / origHeight;\n\t\t}\n\t\treturn scale;\n\t};\n\n\tconst convertImage = async (index: number, image: IImage) => {\n\t\ttry {\n\t\t\tconst dataURL = await ImageHelper.convertBlob(image.file, FileHelper.fileExtensionToMimeType(outputType));\n\t\t\tconst filesize = FileHelper.getFilesizeFromBase64(dataURL);\n\n\t\t\tif (maxSizeInKb && filesize > maxSizeInKb * 1024) {\n\t\t\t\tsetImages((prev) => {\n\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\tstatus: EImageStatus.ERROR_SIZE,\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedImages;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst metadata = await ImageHelper.getMetadata(image.file);\n\t\t\t\tsetImages((prev) => {\n\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\tdataURL,\n\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\tstatus: EImageStatus.CONVERTED,\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedImages;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tstatus: EImageStatus.ERROR_GENERIC,\n\t\t\t\t};\n\t\t\t\treturn updatedImages;\n\t\t\t});\n\t\t}\n\t};\n\n\tconst compressImage = async (index: number, imageToCompress: IImage) => {\n\t\ttry {\n\t\t\tconst dataURL = await ImageHelper.convertBlob(\n\t\t\t\timageToCompress.file,\n\t\t\t\tFileHelper.fileExtensionToMimeType(outputType)\n\t\t\t);\n\t\t\tconst image = await ImageHelper.dataUrlToImage(dataURL);\n\t\t\tconst origDim = { w: image.naturalWidth, h: image.naturalHeight };\n\t\t\tlet compressed: Blob;\n\t\t\tif (crop) {\n\t\t\t\tcompressed = await ImageHelper.resampleImage(image, {\n\t\t\t\t\twidth: dimensions.width,\n\t\t\t\t\theight: dimensions.height,\n\t\t\t\t\tcrop: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst scale = getScale(origDim.w, origDim.h);\n\t\t\t\tcompressed = await ImageHelper.resampleImage(image, { scale });\n\t\t\t}\n\t\t\tif (maxSizeInKb) {\n\t\t\t\tcompressed = (await ImageHelper.compressImage(compressed, {\n\t\t\t\t\tfileSize: maxSizeInKb,\n\t\t\t\t})) as File;\n\t\t\t}\n\n\t\t\tif (maxSizeInKb && compressed.size > maxSizeInKb * 1024) {\n\t\t\t\tsetImages((prev) => {\n\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\tstatus: EImageStatus.ERROR_SIZE,\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedImages;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst metadata = await ImageHelper.getMetadata(imageToCompress.file);\n\t\t\t\tconst dataURL = await FileHelper.fileToDataUrl(compressed);\n\t\t\t\tsetImages((prev) => {\n\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\tdataURL,\n\t\t\t\t\t\tmetadata,\n\t\t\t\t\t\tstatus: EImageStatus.COMPRESSED,\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedImages;\n\t\t\t\t});\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tstatus: EImageStatus.ERROR_GENERIC,\n\t\t\t\t};\n\t\t\t\treturn updatedImages;\n\t\t\t});\n\t\t}\n\t};\n\n\tconst recompressImage = async (index: number, imageToCompress: IImage) => {\n\t\tif (imageToCompress.drawingDataURL) {\n\t\t\ttry {\n\t\t\t\tconst image = await ImageHelper.dataUrlToImage(imageToCompress.drawingDataURL);\n\t\t\t\tconst origDim = { w: image.naturalWidth, h: image.naturalHeight };\n\t\t\t\tlet scaledFile: Blob;\n\t\t\t\tif (crop) {\n\t\t\t\t\tscaledFile = await ImageHelper.resampleImage(image, {\n\t\t\t\t\t\twidth: dimensions.width,\n\t\t\t\t\t\theight: dimensions.height,\n\t\t\t\t\t\tcrop: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst scale = getScale(origDim.w, origDim.h);\n\t\t\t\t\tscaledFile = await ImageHelper.resampleImage(image, { scale });\n\t\t\t\t}\n\t\t\t\tscaledFile = (await ImageHelper.compressImage(scaledFile, { fileSize: maxSizeInKb })) as File;\n\n\t\t\t\tif (scaledFile.size > maxSizeInKb * 1024) {\n\t\t\t\t\tconst updatedImages = [...images];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...images[index],\n\t\t\t\t\t\tstatus: EImageStatus.ERROR_SIZE,\n\t\t\t\t\t};\n\t\t\t\t\tsetImages(updatedImages);\n\t\t\t\t} else {\n\t\t\t\t\tconst dataURL = await FileHelper.fileToDataUrl(scaledFile);\n\t\t\t\t\tconst updatedImages = [...images];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...images[index],\n\t\t\t\t\t\tdrawingDataURL: dataURL,\n\t\t\t\t\t\tstatus: EImageStatus.RECOMPRESSED,\n\t\t\t\t\t};\n\t\t\t\t\tsetImages(updatedImages);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tsetImages((prev) => {\n\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\tstatus: EImageStatus.ERROR_GENERIC,\n\t\t\t\t\t};\n\t\t\t\t\treturn updatedImages;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\tconst uploadImage = async (index: number, iFile: IImage) => {\n\t\ttry {\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tstatus: EImageStatus.UPLOADING,\n\t\t\t\t};\n\t\t\t\treturn updatedImages;\n\t\t\t});\n\n\t\t\tlet response: unknown;\n\t\t\tif (upload?.method && upload?.url) {\n\t\t\t\tconst formData = new FormData();\n\t\t\t\tformData.append(\"dataURL\", iFile.drawingDataURL || iFile.dataURL || \"\");\n\t\t\t\tformData.append(\"sessionId\", upload?.sessionId || sessionId.current || \"\");\n\t\t\t\tformData.append(\"slot\", `${iFile.slot}`);\n\t\t\t\tresponse = await new AxiosApiClient(\"\", undefined, undefined, true)[upload.method](\n\t\t\t\t\tupload.url,\n\t\t\t\t\tformData,\n\t\t\t\t\t{\n\t\t\t\t\t\tonUploadProgress: (progressEvent) => {\n\t\t\t\t\t\t\tconst { loaded, total } = progressEvent;\n\t\t\t\t\t\t\tconst percent = Math.floor((loaded * 100) / total);\n\t\t\t\t\t\t\tsetImages((prev) => {\n\t\t\t\t\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\t\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\t\t\t\tuploadProgress: percent,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturn updatedImages;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tuploadResponse: response,\n\t\t\t\t\tstatus: EImageStatus.UPLOADED,\n\t\t\t\t};\n\t\t\t\treturn updatedImages;\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tsetImages((prev) => {\n\t\t\t\tconst updatedImages = [...prev];\n\t\t\t\tupdatedImages[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tstatus: EImageStatus.ERROR_GENERIC,\n\t\t\t\t};\n\t\t\t\treturn updatedImages;\n\t\t\t});\n\t\t}\n\t};\n\n\treturn null;\n};\n"],"names":["ImageManager","props","accepts","compress","crop","dimensions","editImage","id","maxSizeInKb","outputType","upload","value","images","setImages","setErrorCount","setCurrentFileIds","useContext","ImageContext","previousImages","usePrevious","previousValue","setValue","useFormContext","sessionId","useRef","managerErrorCount","dispatchFieldEvent","addFieldEventListener","removeFieldEventListener","useFieldEvent","useEffect","handleUpdateImageStatus","e","prev","imageIndex","findIndex","image","detail","updatedImage","status","updatedStatus","customErrorMessage","errorMessage","newImages","splice","current","generateRandomId","forEach","index","previousFile","dataURL","EImageStatus","INJECTED","FileHelper","dataUrlToBlob","then","blob","updatedImages","file","File","name","NONE","catch","filter","i","getType","fileType","mimeType","mime","map","fileExtensionToMimeType","includes","deduplicateFileName","sanitizeFileName","type","addedFrom","UPLOADED","compressImage","convertImage","ERROR_FORMAT","TO_RECOMPRESS","recompressImage","COMPRESSED","CONVERTED","RECOMPRESSED","shouldPreventDefault","imageData","PENDING","UPLOAD_READY","uploadImage","TO_DELETE","join","updatedManagerErrorCount","ERROR_GENERIC","ERROR_SIZE","Math","max","uploadedImages","ERROR_CUSTOM_MUTED","notPrefilledImages","gotDeleteImages","length","hasNotPrefilledImages","shouldDirty","drawingDataURL","metadata","uploadResponse","fileId","fileName","shouldTouch","undefined","getScale","origWidth","origHeight","scale","width","height","async","ImageHelper","convertBlob","filesize","getFilesizeFromBase64","getMetadata","imageToCompress","dataUrlToImage","origDim","w","naturalWidth","h","naturalHeight","compressed","resampleImage","fileSize","size","fileToDataUrl","scaledFile","iFile","response","UPLOADING","method","url","formData","FormData","append","slot","AxiosApiClient","onUploadProgress","progressEvent","loaded","total","percent","floor","uploadProgress","err"],"mappings":"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"}