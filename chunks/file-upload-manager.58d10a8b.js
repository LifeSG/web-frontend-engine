import{useContext as e,useRef as t,useEffect as i}from"react";import{F as s,u as a,a as r,b as l,g as o,E as n,c as m,d as p,A as d,I as c}from"./index.2a117e92.js";import"react/jsx-runtime";import"@lifesg/react-design-system/text";import"@lifesg/react-design-system/markup";import"react-dom/server";import"@lifesg/react-design-system/media";import"@lifesg/react-design-system/color";import"styled-components";import"@lifesg/react-design-system/button";import"@lifesg/react-design-system/modal";import"@lifesg/react-design-system/alert";import"@lifesg/react-design-system/layout";import"@lifesg/react-design-system/box-container";import"@lifesg/react-design-system/divider";import"@lifesg/react-design-system/text-list";import"@lifesg/react-design-system/popover-v2";import"@lifesg/react-icons";import"@lifesg/react-design-system/tab";import"@lifesg/react-icons/plus-circle-fill";import"@lifesg/react-design-system/button-with-icon";import"@lifesg/react-design-system/error-display";import"@lifesg/react-design-system/filter";import"@lifesg/react-design-system/uneditable-section";import"@lifesg/react-design-system/timeline";import"@lifesg/react-design-system/form";import"@lifesg/react-design-system/toggle";import"@lifesg/react-design-system/checkbox";import"@lifesg/react-design-system/file-upload";import"@lifesg/react-icons/cross";import"@lifesg/react-design-system/icon-button";import"@lifesg/react-icons/bin";import"@lifesg/react-icons/eraser";import"@lifesg/react-icons/pencil";import"@lifesg/react-icons/pencil-stroke";import"@lifesg/react-design-system";import"@lifesg/react-icons/plus";import"@lifesg/react-icons/exclamation-triangle";import"@lifesg/react-icons/pin-fill";import"@lifesg/react-design-system/design-token";import"@lifesg/react-design-system/image-button";import"@lifesg/react-design-system/radio-button";const f=["image/jpeg","image/gif","image/png"],g=g=>{const{compressImages:u,fileTypeRule:y,hideThumbnail:w,id:I,maxFileSizeRule:F,upload:R,uploadRule:U,value:b}=g,{files:T,setFiles:E,setCurrentFileIds:D}=e(s),h=a(b),{setValue:L}=r(),{dispatchFieldEvent:x}=l(),z=t();i((()=>{z.current=o()}),[]),i((()=>{T.forEach((async(e,t)=>{try{switch(e.status){case n.INJECTED:await P(e,t);break;case n.NONE:await S(e,t);break;case n.UPLOAD_READY:await _(e,t);break;case n.TO_DELETE:k(t)}}catch(e){M(t)}}));const e=T.filter((({status:e})=>e===n.UPLOADED)),t=e.filter((({addedFrom:e})=>"schema"!==e)).length>0,i=T.filter((({status:e})=>e===n.TO_DELETE)).length>0,s=t||i;D(e.map((({fileItem:e})=>e.id))),L(I,e.map((({dataURL:e,fileItem:t,fileUrl:i,uploadResponse:s})=>({..."base64"===R.type?{dataURL:e}:{},fileId:t.id,fileName:t.name,fileUrl:i,uploadResponse:s}))),{shouldDirty:s,shouldTouch:t})}),[T.map((({fileItem:e,status:t})=>`${e?.id}-${t}`)).join(",")]),i((()=>{void 0!==h&&void 0===b&&T.length&&E([])}),[T,h,E,b]);const M=e=>{E((t=>{const i=[...t],s=t[e];return i[e]={...s,fileItem:{...s.fileItem,id:s.fileItem?.id||o(),name:s.rawFile.name,errorMessage:U?.errorMessage||m.UPLOAD().GENERIC},status:n.ERROR_GENERIC},i}))},O=async(e,t)=>{if(!0!==w&&f.includes(t||e.fileItem?.type)){const t=await c.dataUrlToImage(e.dataURL),i=await c.resampleImage(t,{width:94,height:94,crop:!0});return await p.fileToDataUrl(i)}return""},A=async e=>{const{addedFrom:t,dataURL:i,rawFile:s}=e,a=await p.getType(s),r=N(a);if(r?.status<0)return r;const l="base64"===R.type?p.getFilesizeFromBase64(i):s.size,{errorMessage:o,status:m}=v(l);return m<0?{errorMessage:o,fileType:a,status:m}:"schema"===t?{fileType:a,status:n.UPLOADED}:{fileType:a,status:n.UPLOAD_READY}},N=e=>!y.fileType?.length||y.fileType?.includes(e.ext)?{}:{errorMessage:y.errorMessage||m.UPLOAD().FILE_TYPE(y.fileType||[]),fileType:e,status:n.ERROR_FORMAT},v=e=>{if(F.maxSizeInKb>0){if(e>1024*F.maxSizeInKb)return{errorMessage:F.errorMessage||m.UPLOAD().MAX_FILE_SIZE(F.maxSizeInKb),status:n.ERROR_SIZE}}return{}},P=async(e,t)=>{let i;if(E((e=>{const i=[...e];return i[t]={...e[t],status:n.INJECTING},i})),e.dataURL){const t=await p.dataUrlToBlob(e.dataURL);i=new File([t],e.rawFile.name)}else if(e.fileUrl){const t=await new d("",void 0,void 0,!1,{responseType:"blob"}).get(e.fileUrl),s=await p.getType(new File([t],e.rawFile.name));i=new File([t],e.rawFile.name,{type:s.mime}),e.dataURL=await p.fileToDataUrl(i)}const{errorMessage:s,fileType:a}=i?await A({...e,rawFile:i}):N({mime:e.uploadResponse?.mimeType,ext:e.uploadResponse?.ext});let r=i?.size||e.uploadResponse?.fileSize||0;isNaN(r)&&(r=0);const{errorMessage:l}=v(r),m=i?await O(e,a?.mime):void 0;E((d=>{const c=[...d];return c[t]={...e,fileItem:{errorMessage:s||l,id:e.fileItem?.id||o(),name:p.deduplicateFileName(T.map((({fileItem:e})=>e.name)),t,i?.name||e.rawFile.name),progress:1,size:r,type:a?.mime||e.uploadResponse?.mimeType,thumbnailImageDataUrl:m},rawFile:i,status:n.UPLOADED},c}))},S=async(e,t)=>{const i=await C(e),s=await p.fileToDataUrl(i.rawFile),{errorMessage:a,fileType:r,status:l}=await A({dataURL:s,...i});E((e=>{const n=[...e];return n[t]={...i,dataURL:s,fileItem:{errorMessage:a,id:o(),name:p.deduplicateFileName(T.map((({fileItem:e})=>e?.name)),t,p.sanitizeFileName(i.rawFile.name)),size:i.rawFile.size,type:r.mime,progress:0},status:l},n}))},_=async(e,t)=>{E((e=>{const i=[...e];return i[t]={...e[t],status:n.UPLOADING},i}));const i=new FormData;i.append("sessionId",R?.sessionId||z.current||""),i.append("fileId",e.fileItem.id),i.append("slot",e.slot.toString()),"base64"===R.type?i.append("dataURL",e.dataURL):"multipart"===R.type&&i.append("file",e.rawFile,e.fileItem?.name);try{const s=await new d("",void 0,void 0,!0).post(R.url,i,{headers:{"Content-Type":"base64"===R.type?"application/json":"multipart/form-data",...R.headers},onUploadProgress:e=>{const{loaded:i,total:s}=e;E((e=>{if(!e[t])return e;const a=[...e];return a[t]={...e[t],fileItem:{...e[t].fileItem,progress:i/s}},a}))}}),a=await O(e);E((e=>{if(!e[t])return e;const i=[...e];return i[t]={...e[t],fileItem:{...e[t].fileItem,progress:1,thumbnailImageDataUrl:a},fileUrl:s?.data?.fileUrl,status:n.UPLOADED,uploadResponse:s},i}))}catch(t){throw x("upload-error",I,{fileId:e.fileItem.id,errorData:t?.response?.data}),t}},k=e=>{E((t=>t.filter(((t,i)=>i!==e))))},C=async e=>{if(F.maxSizeInKb>0&&u){const t=1024*F.maxSizeInKb;if(e.rawFile.size>t){const t=await p.getType(e.rawFile);if(f.includes(t.mime)){let t=await c.compressImage(e.rawFile,{fileSize:F.maxSizeInKb});return t instanceof Blob&&(t=p.blobToFile(t,{name:e.rawFile.name,lastModified:e.rawFile.lastModified})),{...e,rawFile:t}}}}return e};return null};export{g as default};
//# sourceMappingURL=file-upload-manager.58d10a8b.js.map
