import{useContext as t,useState as e,useRef as s,useEffect as a}from"react";import{I as i,u as r,a as o,E as n,F as l,b as c,A as m}from"./index.b7258ea0.js";import"react/jsx-runtime";import"events";import"buffer";import"@lifesg/react-design-system/media";import"@lifesg/react-design-system/text";import"@lifesg/react-design-system/color";import"styled-components";import"@lifesg/react-design-system/modal";import"@lifesg/react-design-system/button";import"react-dom/server";import"@lifesg/react-design-system/layout";import"@lifesg/react-design-system/alert";import"@lifesg/react-design-system/divider";import"@lifesg/react-design-system";import"@lifesg/react-design-system/uneditable-section";import"@lifesg/react-design-system/form";import"@lifesg/react-design-system/toggle";import"@lifesg/react-design-system/checkbox";import"@lifesg/react-design-system/input-textarea";import"@lifesg/react-icons/cross";import"@lifesg/react-design-system/icon-button";import"@lifesg/react-icons/pin-fill";import"@lifesg/react-design-system/radio-button";const d=d=>{const{accepts:u,compress:p,dimensions:R,editImage:E,id:g,maxSizeInKb:f,outputType:h,upload:y,value:D}=d,{images:O,setImages:U,setErrorCount:w}=t(i),T=r(O),[L,I]=e(0),S=r(D),{setValue:b,getFieldState:_}=o(),N=s();a((()=>{N.current=Array(5).fill(0).map((()=>Math.random().toString(36).slice(2))).join("")}),[]),a((()=>{O.forEach(((t,e)=>{const s=T?.[e];if(t.status!==s?.status||t.dataURL!==s.dataURL)switch(t.status){case n.INJECTED:l.dataUrlToBlob(t.dataURL).then((s=>{U((a=>{const i=[...a];return i[e]={...t,file:new File([s],t.name),status:n.NONE},i}))})).catch((()=>{U((t=>t.filter(((t,s)=>s!==e))))}));break;case n.NONE:l.getMimeType(t.file).then((s=>{s&&u.map(l.fileExtensionToMimeType).includes(s)?(U((a=>{const i=[...a];return i[e]={...t,name:l.deduplicateFileName(O.map((({name:t})=>t)),e,t.name),type:s,status:"schema"!==t.addedFrom?t.status:n.UPLOADED},i})),"schema"!==t.addedFrom&&(p?P(e,t):M(e,t))):U((s=>{const a=[...s];return a[e]={...t,status:n.ERROR_FORMAT},a}))}));break;case n.TO_RECOMPRESS:v(e,t);break;case n.COMPRESSED:case n.CONVERTED:case n.RECOMPRESSED:E||U((t=>{const s=[...t];return s[e]={...s[e],status:n.UPLOAD_READY},s}));break;case n.UPLOAD_READY:x(e,t);break;case n.TO_DELETE:U((t=>t.filter((({status:t})=>t!==n.TO_DELETE))))}}))}),[O.map((({status:t})=>t)).join(","),O.map((({dataURL:t})=>t)).join(",")]),a((()=>{let t=0;O.forEach((e=>{(e.type&&!u.map(l.fileExtensionToMimeType).includes(e.type)||[n.ERROR_GENERIC,n.ERROR_SIZE].includes(e.status))&&t++})),w((e=>Math.max(0,e+t-L))),I(t);const e=O.filter((({status:t})=>t===n.UPLOADED)),s=e.filter((({addedFrom:t})=>"schema"!==t)),a=O.filter((({status:t})=>t===n.TO_DELETE)).length>0,i=s.length>0||a;b(g,e.map((({dataURL:t,drawingDataURL:e,name:s,uploadResponse:a})=>({fileName:s,dataURL:e||t,uploadResponse:a}))),{shouldDirty:i})}),[O.map((t=>t.status)).join(",")]),a((()=>{void 0!==S&&void 0===D&&O.length&&U([])}),[void 0===S,void 0===D,O.length]);const C=(t,e)=>{let s=R.width/t;return e*s>R.height&&(s=R.height/e),s},M=async(t,e)=>{try{const s=await c.convertBlob(e.file,l.fileExtensionToMimeType(h)),a=l.getFilesizeFromBase64(s);U(f&&a>1024*f?e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_SIZE},s}:e=>{const a=[...e];return a[t]={...e[t],dataURL:s,status:n.CONVERTED},a})}catch(e){U((e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_GENERIC},s}))}},P=async(t,e)=>{try{const s=await l.fileToDataUrl(e.file),a=await c.dataUrlToImage(s),i={w:a.naturalWidth,h:a.naturalHeight},r=C(i.w,i.h);let o=await c.resampleImage(a,{scale:r});if(f&&(o=await c.compressImage(o,{fileSize:f})),f&&o.size>1024*f)U((e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_SIZE},s}));else{const e=await l.fileToDataUrl(o);U((s=>{const a=[...s];return a[t]={...s[t],dataURL:e,status:n.COMPRESSED},a}))}}catch(e){U((e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_GENERIC},s}))}},v=async(t,e)=>{if(e.drawingDataURL)try{const s=await c.dataUrlToImage(e.drawingDataURL),a={w:s.naturalWidth,h:s.naturalHeight},i=C(a.w,a.h);let r=await c.resampleImage(s,{scale:i});if(r=await c.compressImage(r,{fileSize:f}),r.size>1024*f){const e=[...O];e[t]={...O[t],status:n.ERROR_SIZE},U(e)}else{const e=await l.fileToDataUrl(r),s=[...O];s[t]={...O[t],drawingDataURL:e,status:n.RECOMPRESSED},U(s)}}catch(e){U((e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_GENERIC},s}))}},x=async(t,e)=>{try{let s;if(U((e=>{const s=[...e];return s[t]={...e[t],status:n.UPLOADING},s})),y?.method&&y?.url){const a=new FormData;a.append("dataURL",e.drawingDataURL||e.dataURL||""),a.append("sessionId",N.current||""),a.append("slot",`${e.slot}`),s=await new m("",void 0,void 0,!0)[y.method](y.url,a,{onUploadProgress:e=>{const{loaded:s,total:a}=e,i=Math.floor(100*s/a);U((e=>{const s=[...e];return s[t]={...e[t],uploadProgress:i},s}))}})}U((e=>{const a=[...e];return a[t]={...e[t],uploadResponse:s,status:n.UPLOADED},a}))}catch(e){U((e=>{const s=[...e];return s[t]={...e[t],status:n.ERROR_GENERIC},s}))}};return null};export{d as default};
//# sourceMappingURL=index.add23af8.js.map
