{"version":3,"file":"file-upload-manager.c18e0e39.js","sources":["../../../src/components/fields/file-upload/file-upload-manager.ts"],"sourcesContent":["import { AxiosError } from \"axios\";\nimport { useContext, useEffect, useRef } from \"react\";\nimport { useFormContext } from \"react-hook-form\";\nimport { AxiosApiClient, FileHelper, ImageHelper, generateRandomId } from \"../../../utils\";\nimport { useFieldEvent, usePrevious } from \"../../../utils/hooks\";\nimport { ERROR_MESSAGES } from \"../../shared\";\nimport { FileUploadContext } from \"./file-upload-context\";\nimport {\n\tEFileStatus,\n\tIFile,\n\tIFileUploadSchema,\n\tIFileUploadValidationRule,\n\tIFileUploadValue,\n\tTUploadErrorDetail,\n} from \"./types\";\n\ninterface IProps {\n\tcompressImages: boolean;\n\tfileTypeRule: IFileUploadValidationRule;\n\tid: string;\n\tmaxFileSizeRule: IFileUploadValidationRule;\n\tupload: IFileUploadSchema[\"uploadOnAddingFile\"];\n\tuploadRule: IFileUploadValidationRule;\n\tvalue: IFileUploadValue[];\n}\n\nconst RESIZEABLE_IMAGE_TYPES = [\"image/jpeg\", \"image/gif\", \"image/png\"];\n\nconst FileUploadManager = (props: IProps) => {\n\t// =============================================================================\n\t// CONST, STATE, REFS\n\t// =============================================================================\n\tconst { compressImages, fileTypeRule, id, maxFileSizeRule, upload, uploadRule, value } = props;\n\tconst { files, setFiles, setCurrentFileIds } = useContext(FileUploadContext);\n\tconst previousValue = usePrevious(value);\n\tconst { setValue } = useFormContext();\n\tconst { dispatchFieldEvent } = useFieldEvent();\n\tconst sessionId = useRef<string>();\n\n\t// =============================================================================\n\t// EFFECTS\n\t// =============================================================================\n\tuseEffect(() => {\n\t\tsessionId.current = generateRandomId();\n\t}, []);\n\n\tuseEffect(\n\t\t() => {\n\t\t\t// handle file status\n\t\t\tfiles.forEach(async (file, index) => {\n\t\t\t\ttry {\n\t\t\t\t\tswitch (file.status) {\n\t\t\t\t\t\tcase EFileStatus.INJECTED:\n\t\t\t\t\t\t\tawait injectFile(file, index);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EFileStatus.NONE:\n\t\t\t\t\t\t\tawait parseFile(file, index);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EFileStatus.UPLOAD_READY:\n\t\t\t\t\t\t\tawait uploadFile(file, index);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase EFileStatus.TO_DELETE:\n\t\t\t\t\t\t\tdeleteFile(index);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\thandleGenericError(index);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// track / update values\n\t\t\tconst uploadedFiles = files.filter(({ status }) => status === EFileStatus.UPLOADED);\n\t\t\tconst notPrefilledFiles = uploadedFiles.filter(({ addedFrom }) => addedFrom !== \"schema\");\n\t\t\tconst hasNotPrefilledFiles = notPrefilledFiles.length > 0;\n\t\t\tconst gotDeleteFiles = files.filter(({ status }) => status === EFileStatus.TO_DELETE).length > 0;\n\n\t\t\t/**\n\t\t\t * should dirty if\n\t\t\t * - it is dirty in the first place\n\t\t\t * - there are non-prefilled files\n\t\t\t * - user deleted file (differentiated from reset)\n\t\t\t */\n\t\t\tconst shouldDirty = hasNotPrefilledFiles || gotDeleteFiles;\n\n\t\t\tsetCurrentFileIds(uploadedFiles.map(({ fileItem }) => fileItem.id));\n\n\t\t\tsetValue(\n\t\t\t\tid,\n\t\t\t\tuploadedFiles.map(({ dataURL, fileItem, fileUrl, uploadResponse }) => ({\n\t\t\t\t\t...(upload.type === \"base64\" ? { dataURL } : {}),\n\t\t\t\t\tfileId: fileItem.id,\n\t\t\t\t\tfileName: fileItem.name,\n\t\t\t\t\tfileUrl,\n\t\t\t\t\tuploadResponse,\n\t\t\t\t})),\n\t\t\t\t{ shouldDirty, shouldTouch: hasNotPrefilledFiles }\n\t\t\t);\n\t\t}, // eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[files.map(({ fileItem, status }) => `${fileItem?.id}-${status}`).join(\",\")]\n\t);\n\n\t// for reset\n\tuseEffect(() => {\n\t\tif (previousValue !== undefined && value === undefined && files.length) {\n\t\t\tsetFiles([]);\n\t\t}\n\t}, [files, previousValue, setFiles, value]);\n\n\t// =============================================================================\n\t// HELPER FUNCTIONS\n\t// =============================================================================\n\n\tconst handleGenericError = (index: number) => {\n\t\tsetFiles((prev) => {\n\t\t\tconst updatedFiles = [...prev];\n\t\t\tconst file = prev[index];\n\t\t\tupdatedFiles[index] = {\n\t\t\t\t...file,\n\t\t\t\tfileItem: {\n\t\t\t\t\t...file.fileItem,\n\t\t\t\t\tid: file.fileItem?.id || generateRandomId(),\n\t\t\t\t\tname: file.rawFile.name,\n\t\t\t\t\terrorMessage: uploadRule?.errorMessage || ERROR_MESSAGES.UPLOAD().GENERIC,\n\t\t\t\t},\n\t\t\t\tstatus: EFileStatus.ERROR_GENERIC,\n\t\t\t};\n\t\t\treturn updatedFiles;\n\t\t});\n\t};\n\n\tconst generateThumbnail = async (file: IFile, fileType?: string | undefined) => {\n\t\tif (RESIZEABLE_IMAGE_TYPES.includes(fileType || file.fileItem?.type)) {\n\t\t\tconst image = await ImageHelper.dataUrlToImage(file.dataURL);\n\t\t\tconst thumbnail = await ImageHelper.resampleImage(image, { width: 94, height: 94, crop: true });\n\t\t\treturn await FileHelper.fileToDataUrl(thumbnail);\n\t\t}\n\t\treturn \"\";\n\t};\n\n\tconst readFile = async (fileToRead: IFile) => {\n\t\tconst { addedFrom, dataURL, rawFile } = fileToRead;\n\t\tconst fileType = await FileHelper.getType(rawFile);\n\t\tconst validFileType = fileTypeRule.fileType?.length ? fileTypeRule.fileType?.includes(fileType.ext) : true;\n\n\t\tif (!validFileType) {\n\t\t\treturn {\n\t\t\t\terrorMessage:\n\t\t\t\t\tfileTypeRule.errorMessage || ERROR_MESSAGES.UPLOAD().FILE_TYPE(fileTypeRule.fileType || []),\n\t\t\t\tfileType,\n\t\t\t\tstatus: EFileStatus.ERROR_FORMAT,\n\t\t\t};\n\t\t}\n\n\t\tif (maxFileSizeRule.maxSizeInKb > 0) {\n\t\t\tconst maxSizeInB = maxFileSizeRule.maxSizeInKb * 1024;\n\t\t\tif (\n\t\t\t\t(upload.type === \"base64\" && FileHelper.getFilesizeFromBase64(dataURL) > maxSizeInB) ||\n\t\t\t\t(upload.type === \"multipart\" && rawFile.size > maxSizeInB)\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\terrorMessage:\n\t\t\t\t\t\tmaxFileSizeRule.errorMessage ||\n\t\t\t\t\t\tERROR_MESSAGES.UPLOAD().MAX_FILE_SIZE(maxFileSizeRule.maxSizeInKb),\n\t\t\t\t\tfileType,\n\t\t\t\t\tstatus: EFileStatus.ERROR_SIZE,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (addedFrom === \"schema\") {\n\t\t\treturn {\n\t\t\t\tfileType,\n\t\t\t\tstatus: EFileStatus.UPLOADED,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tfileType,\n\t\t\tstatus: EFileStatus.UPLOAD_READY,\n\t\t};\n\t};\n\n\t// =============================================================================\n\t// FILE STATUS HANDLERS\n\t// =============================================================================\n\tconst injectFile = async (fileToInject: IFile, index: number) => {\n\t\tsetFiles((prev) => {\n\t\t\tconst updatedFiles = [...prev];\n\t\t\tupdatedFiles[index] = {\n\t\t\t\t...prev[index],\n\t\t\t\tstatus: EFileStatus.INJECTING,\n\t\t\t};\n\t\t\treturn updatedFiles;\n\t\t});\n\n\t\tlet rawFile: File;\n\t\tif (fileToInject.dataURL) {\n\t\t\tconst blob = await FileHelper.dataUrlToBlob(fileToInject.dataURL);\n\t\t\trawFile = new File([blob], fileToInject.rawFile.name);\n\t\t} else if (fileToInject.fileUrl) {\n\t\t\tconst response: Blob = await new AxiosApiClient(\"\", undefined, undefined, false, {\n\t\t\t\tresponseType: \"blob\",\n\t\t\t}).get(fileToInject.fileUrl);\n\t\t\tconst fileType = await FileHelper.getType(new File([response], fileToInject.rawFile.name));\n\t\t\trawFile = new File([response], fileToInject.rawFile.name, { type: fileType.mime });\n\t\t\tfileToInject.dataURL = await FileHelper.fileToDataUrl(rawFile);\n\t\t}\n\t\tconst { errorMessage, fileType } = await readFile({ ...fileToInject, rawFile });\n\t\tconst thumbnailImageDataUrl = await generateThumbnail(fileToInject, fileType.mime);\n\n\t\tsetFiles((prev) => {\n\t\t\tconst updatedFiles = [...prev];\n\t\t\tupdatedFiles[index] = {\n\t\t\t\t...fileToInject,\n\t\t\t\tfileItem: {\n\t\t\t\t\terrorMessage,\n\t\t\t\t\tid: fileToInject.fileItem?.id || generateRandomId(),\n\t\t\t\t\tname: FileHelper.deduplicateFileName(\n\t\t\t\t\t\tfiles.map(({ fileItem }) => fileItem?.name),\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\trawFile.name\n\t\t\t\t\t),\n\t\t\t\t\tprogress: 1,\n\t\t\t\t\tsize: rawFile.size,\n\t\t\t\t\ttype: fileType.mime,\n\t\t\t\t\tthumbnailImageDataUrl,\n\t\t\t\t},\n\t\t\t\trawFile,\n\t\t\t\tstatus: EFileStatus.UPLOADED,\n\t\t\t};\n\t\t\treturn updatedFiles;\n\t\t});\n\t};\n\n\tconst parseFile = async (fileToParse: IFile, index: number) => {\n\t\tconst compressedFile = await compressImageFile(fileToParse);\n\t\tconst dataURL = await FileHelper.fileToDataUrl(compressedFile.rawFile);\n\t\tconst { errorMessage, fileType, status } = await readFile({ dataURL, ...compressedFile });\n\n\t\tsetFiles((prev) => {\n\t\t\tconst updatedFiles = [...prev];\n\t\t\tupdatedFiles[index] = {\n\t\t\t\t...compressedFile,\n\t\t\t\tdataURL,\n\t\t\t\tfileItem: {\n\t\t\t\t\terrorMessage,\n\t\t\t\t\tid: generateRandomId(),\n\t\t\t\t\tname: FileHelper.deduplicateFileName(\n\t\t\t\t\t\tfiles.map(({ fileItem }) => fileItem?.name),\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tFileHelper.sanitizeFileName(compressedFile.rawFile.name)\n\t\t\t\t\t),\n\t\t\t\t\tsize: compressedFile.rawFile.size,\n\t\t\t\t\ttype: fileType.mime,\n\t\t\t\t\tprogress: 0,\n\t\t\t\t},\n\t\t\t\tstatus,\n\t\t\t};\n\t\t\treturn updatedFiles;\n\t\t});\n\t};\n\n\tconst uploadFile = async (fileToUpload: IFile, index: number) => {\n\t\tsetFiles((prev) => {\n\t\t\tconst updatedFiles = [...prev];\n\t\t\tupdatedFiles[index] = {\n\t\t\t\t...prev[index],\n\t\t\t\tstatus: EFileStatus.UPLOADING,\n\t\t\t};\n\t\t\treturn updatedFiles;\n\t\t});\n\n\t\tconst formData = new FormData();\n\t\tformData.append(\"sessionId\", upload?.sessionId || sessionId.current || \"\");\n\t\tformData.append(\"fileId\", fileToUpload.fileItem.id);\n\t\tformData.append(\"slot\", fileToUpload.slot.toString());\n\t\tif (upload.type === \"base64\") {\n\t\t\tformData.append(\"dataURL\", fileToUpload.dataURL);\n\t\t} else if (upload.type === \"multipart\") {\n\t\t\tformData.append(\"file\", fileToUpload.rawFile, fileToUpload.fileItem?.name);\n\t\t}\n\n\t\ttry {\n\t\t\tconst response = await new AxiosApiClient(\"\", undefined, undefined, true).post(upload.url, formData, {\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": upload.type === \"base64\" ? \"application/json\" : \"multipart/form-data\",\n\t\t\t\t\t...upload.headers,\n\t\t\t\t},\n\t\t\t\tonUploadProgress: (progressEvent) => {\n\t\t\t\t\tconst { loaded, total } = progressEvent;\n\t\t\t\t\tsetFiles((prev) => {\n\t\t\t\t\t\tif (!prev[index]) return prev;\n\t\t\t\t\t\tconst updatedFiles = [...prev];\n\t\t\t\t\t\tupdatedFiles[index] = {\n\t\t\t\t\t\t\t...prev[index],\n\t\t\t\t\t\t\tfileItem: {\n\t\t\t\t\t\t\t\t...prev[index].fileItem,\n\t\t\t\t\t\t\t\tprogress: loaded / total,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\treturn updatedFiles;\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tconst thumbnailImageDataUrl = await generateThumbnail(fileToUpload);\n\t\t\tsetFiles((prev) => {\n\t\t\t\tif (!prev[index]) return prev;\n\t\t\t\tconst updatedFiles = [...prev];\n\t\t\t\tupdatedFiles[index] = {\n\t\t\t\t\t...prev[index],\n\t\t\t\t\tfileItem: {\n\t\t\t\t\t\t...prev[index].fileItem,\n\t\t\t\t\t\tprogress: 1,\n\t\t\t\t\t\tthumbnailImageDataUrl,\n\t\t\t\t\t},\n\t\t\t\t\tfileUrl: response?.[\"data\"]?.[\"fileUrl\"],\n\t\t\t\t\tstatus: EFileStatus.UPLOADED,\n\t\t\t\t\tuploadResponse: response,\n\t\t\t\t};\n\t\t\t\treturn updatedFiles;\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tdispatchFieldEvent<TUploadErrorDetail>(\"upload-error\", id, {\n\t\t\t\tfileId: fileToUpload.fileItem.id,\n\t\t\t\terrorData: (err as AxiosError)?.response?.data,\n\t\t\t});\n\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\tconst deleteFile = (index: number) => {\n\t\tsetFiles((prev) => prev.filter((_file, i) => i !== index));\n\t};\n\n\tconst compressImageFile = async (fileToCompress: IFile) => {\n\t\tif (maxFileSizeRule.maxSizeInKb > 0 && compressImages) {\n\t\t\tconst maxSizeInB = maxFileSizeRule.maxSizeInKb * 1024;\n\t\t\tif (fileToCompress.rawFile.size > maxSizeInB) {\n\t\t\t\tconst fileType = await FileHelper.getType(fileToCompress.rawFile);\n\t\t\t\tif (RESIZEABLE_IMAGE_TYPES.includes(fileType.mime)) {\n\t\t\t\t\tlet fileOrBlob = await ImageHelper.compressImage(fileToCompress.rawFile, {\n\t\t\t\t\t\tfileSize: maxFileSizeRule.maxSizeInKb,\n\t\t\t\t\t});\n\t\t\t\t\tif (fileOrBlob instanceof Blob) {\n\t\t\t\t\t\tfileOrBlob = FileHelper.blobToFile(fileOrBlob, {\n\t\t\t\t\t\t\tname: fileToCompress.rawFile.name,\n\t\t\t\t\t\t\tlastModified: fileToCompress.rawFile.lastModified,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...fileToCompress,\n\t\t\t\t\t\trawFile: fileOrBlob,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fileToCompress;\n\t};\n\n\t// =============================================================================\n\t// RENDER FUNCTIONS\n\t// =============================================================================\n\treturn null;\n};\n\nexport default FileUploadManager;\n"],"names":["RESIZEABLE_IMAGE_TYPES","props","compressImages","fileTypeRule","id","maxFileSizeRule","upload","uploadRule","value","files","setFiles","setCurrentFileIds","useContext","FileUploadContext","previousValue","usePrevious","setValue","useFormContext","dispatchFieldEvent","useFieldEvent","sessionId","useRef","useEffect","current","generateRandomId","forEach","async","file","index","status","EFileStatus","INJECTED","injectFile","NONE","parseFile","UPLOAD_READY","uploadFile","TO_DELETE","deleteFile","err","handleGenericError","uploadedFiles","filter","UPLOADED","hasNotPrefilledFiles","addedFrom","length","gotDeleteFiles","shouldDirty","map","fileItem","dataURL","fileUrl","uploadResponse","type","fileId","fileName","name","shouldTouch","join","undefined","prev","updatedFiles","rawFile","errorMessage","ERROR_MESSAGES","UPLOAD","GENERIC","ERROR_GENERIC","generateThumbnail","fileType","includes","image","ImageHelper","dataUrlToImage","thumbnail","resampleImage","width","height","crop","FileHelper","fileToDataUrl","readFile","fileToRead","getType","ext","FILE_TYPE","ERROR_FORMAT","maxSizeInKb","maxSizeInB","getFilesizeFromBase64","size","MAX_FILE_SIZE","ERROR_SIZE","fileToInject","INJECTING","blob","dataUrlToBlob","File","response","AxiosApiClient","responseType","get","mime","thumbnailImageDataUrl","deduplicateFileName","progress","fileToParse","compressedFile","compressImageFile","sanitizeFileName","fileToUpload","UPLOADING","formData","FormData","append","slot","toString","post","url","headers","onUploadProgress","progressEvent","loaded","total","errorData","data","_file","i","fileToCompress","fileOrBlob","compressImage","fileSize","Blob","blobToFile","lastModified"],"mappings":"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"}